<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Spelling Flashcards (TTS)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; background: #f6f7fb; }
    .wrap { max-width: 820px; margin: 0 auto; padding: 20px; }
    .card {
      background: white; border-radius: 18px; padding: 28px;
      box-shadow: 0 10px 25px rgba(0,0,0,.08);
      min-height: 240px; display: flex; flex-direction: column; gap: 14px;
    }
    h1 { margin: 10px 0 18px; font-size: 20px; color: #222; }
    .word { font-size: 44px; font-weight: 800; letter-spacing: .2px; }
    .meta { color: #555; font-size: 14px; }
    .controls { display: flex; flex-wrap: wrap; gap: 10px; margin-top: 14px; }
    button, select, input {
      border-radius: 12px; border: 1px solid #d8dbe6; background: #fff;
      padding: 10px 14px; font-size: 14px; cursor: pointer;
    }
    button.primary { background: #111827; color: white; border-color: #111827; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .spacer { flex: 1; }
    .small { font-size: 12px; color: #666; line-height: 1.35; }
    .input { width: 100%; min-height: 110px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    details { background: #eef1fb; border-radius: 14px; padding: 10px 12px; }
    a { color: #1f4ed8; text-decoration: none; }
    a:hover { text-decoration: underline; }
    .pill { padding: 4px 10px; border-radius: 999px; border: 1px solid #d8dbe6; background: #fff; }
    /* New styles for status buttons & dashboard */
    .status-controls { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .status-btn {
      padding: 6px 10px; border-radius: 10px; font-size: 13px;
      border: 1px solid #d1d5db; background: #fff; cursor: pointer;
    }
    .status-btn.active { background: #10b981; color: white; border-color: #10b981; }
    .status-btn.mastered { background: #60a5fa; border-color: #3b82f6; color: white; }
    .status-btn.clear { background: #fff; border-color: #f3f4f6; color: #111827; }
    #dashboard { display:flex; gap:12px; align-items:center; font-size:13px; }
    #dashboard .dash-item { background:#f8fafc; border-radius:10px; padding:8px 12px; border:1px solid #eef2ff; }
    #progressBar { height:10px; background:#e6eef8; border-radius:999px; width:160px; overflow:hidden; display:inline-block; vertical-align:middle; }
    #progressFill { height:100%; background:#60a5fa; width:0%; transition:width .25s ease; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Spelling Flashcards (device text-to-speech)</h1>

    <div class="card">
      <div class="row">
        <div class="meta" id="counter">0 / 0</div>
        <div class="spacer"></div>

        <span class="pill small" id="ttsStatus">TTS: checking‚Ä¶</span>

        <label class="small">Mode:</label>
        <select id="mode">
          <option value="show">Show word</option>
          <option value="hide">Hide word (quiz)</option>
        </select>

        <button id="shuffleBtn">Shuffle</button>
      </div>

      <!-- Dashboard showing counts and progress -->
      <div class="row" style="margin-top:6px;">
        <div id="dashboard" aria-live="polite">
          <div class="dash-item">Spelled: <b id="countSpelled">0</b></div>
          <div class="dash-item">Mastered: <b id="countMastered">0</b></div>
          <div class="dash-item">Not Mastered: <b id="countNotMastered">0</b></div>
          <div class="dash-item" title="Mastered progress">
            <span id="progressBar"><span id="progressFill"></span></span>
            <span style="margin-left:8px;"><b id="percentMastered">0%</b></span>
          </div>
        </div>
      </div>

      <div id="wordArea">
        <div class="word" id="word">‚Äî</div>
        <!-- Status buttons for the current word will be rendered into this container -->
        <div id="statusArea" class="status-controls" aria-live="polite"></div>
      </div>

      <div class="row">
        <button class="primary" id="revealBtn">Reveal</button>
        <button id="prevBtn">Back</button>
        <button id="nextBtn" class="primary">Next</button>

        <div class="spacer"></div>

        <button id="speakBtn" class="primary">üîä Speak</button>
        <button id="stopBtn">Stop</button>
      </div>

      <div class="row">
        <label class="small">Voice:</label>
        <select id="voiceSelect"></select>

        <label class="small">Speed:</label>
        <select id="rate">
          <option value="0.8">Slow</option>
          <option value="1" selected>Normal</option>
          <option value="1.2">Fast</option>
        </select>

        <label class="small">Repeat:</label>
        <select id="repeat">
          <option value="1" selected>1x</option>
          <option value="2">2x</option>
          <option value="3">3x</option>
        </select>
      </div>

      <div class="small" id="hint">
        Tip: On iPhone/iPad, you may need to tap ‚ÄúSpeak‚Äù once to allow audio. If device TTS isn‚Äôt available, use the backup links:
        <span id="backupLinks"></span>
      </div>

      <details>
        <summary><b>Edit word list</b> (paste one word per line)</summary>
        <p class="small">Tip: you can paste your Three Bee list, or combine all levels.</p>
        <textarea id="wordList" class="input"></textarea>
        <div class="controls">
          <button id="loadBtn" class="primary">Load List</button>
          <button id="resetBtn">Reset to default</button>
        </div>
      </details>
    </div>
  </div>

  <script>
    // Default list: Three Bee words (one per line)
    const DEFAULT_WORDS = `
gangly
hesitate
scorcher
scavenger
fragments
deflated
unleash
ration
cosmetics
crawdad
frustration
unruly
mascot
aroma
moustache
artifacts
perfume
sinister
tuxedo
discoveries
lurches
language
prognosis
Buffalo
sequins
gallop
fabulous
lanky
fluently
mysterious
brandished
sardines
anguish
conical
rickety
lilt
pediatric
porridge
democracy
rummage
beige
ancestral
grimace
gaunt
enormous
geranium
nautical
dubious
ebony
foreign
paltry
verdict
garbled
encourages
imitation
miniature
receptionist
preamble
plausible
reprimanding
commotion
oblivion
immigrants
steeple
spectators
lanyards
suspicious
parchment
ramshackle
fugitive
heron
dissolving
nomad
billowed
skewer
Berlin
lunacy
conjure
bracken
noggin
neon
rakish
hypnosis
rotunda
gusto
toiletries
gleaned
jeered
winsome
prattling
galore
emporium
atrium
eccentric
savant
swaggering
chimneys
riveted
plaid
dirge
zeal
whittled
depots
fiberglass
salvaged
fissures
enthusiastic
discipline
unfamiliar
scurrying
dignitaries
pizzeria
dismissal
skittish
careened
nomination
opportunist
dictatorship
comrades
sporadic
promenade
repugnant
invincible
renowned
parachute
laborious
appointment
foreseeable
ratify
scalpel
reclusive
compassionate
bulletin
alfalfa
officially
crematorium
bayonet
amicable
exuberant
beautician
equations
assignment
ultimatum
whinnying
squalor
memoirs
cylinders
ominous
muffler
syndrome
premises
safari
lasagna
substantially
mercantile
formidable
propaganda
marquee
proficient
compunction
emphatically
hyperventilated
ostracism
onslaught
ruefully
misanthrope
prototype
cravenly
mulberry
hypocritical
chlorine
traumatic
receipts
solemnly
begrudge
contentious
precocious
ensemble
cadre
lye
belfry
lacrosse
sluice
cajolery
vigilance
residuals
boutique
peroxide
aristocracy
apocalypse
almanac
hippies
samosas
campaign
pistachio
mosque
zombielike
warlock
colossus
convulsively
dimensional
garishly
graffitist
Everest
dexterity
cavorting
marauder
conscience
battlements
deferential
albatross
khaki
opalescent
asphalt
Yiddish
talcum
tranquilizer
equestrian
plaited
monsieur
manticores
prestigious
fraidycat
guttural
lo mein
courier
sans serif
psyche
stucco
Frankenstein
schema
et cetera
vidimus
delphine
slough
archipelago
serape
puissance
pinioning
chignon
pheromone
galleon
magnanimous
chartreuse
wainscoting

`.trim();

    const els = {
      counter: document.getElementById("counter"),
      word: document.getElementById("word"),
      mode: document.getElementById("mode"),
      revealBtn: document.getElementById("revealBtn"),
      prevBtn: document.getElementById("prevBtn"),
      nextBtn: document.getElementById("nextBtn"),
      shuffleBtn: document.getElementById("shuffleBtn"),
      speakBtn: document.getElementById("speakBtn"),
      stopBtn: document.getElementById("stopBtn"),
      voiceSelect: document.getElementById("voiceSelect"),
      rate: document.getElementById("rate"),
      repeat: document.getElementById("repeat"),
      wordList: document.getElementById("wordList"),
      loadBtn: document.getElementById("loadBtn"),
      resetBtn: document.getElementById("resetBtn"),
      backupLinks: document.getElementById("backupLinks"),
      ttsStatus: document.getElementById("ttsStatus"),
      statusArea: document.getElementById("statusArea"),
      countSpelled: document.getElementById("countSpelled"),
      countMastered: document.getElementById("countMastered"),
      countNotMastered: document.getElementById("countNotMastered"),
      progressFill: document.getElementById("progressFill"),
      percentMastered: document.getElementById("percentMastered"),
    };

    let words = [];
    let idx = 0;
    let revealed = true;
    let voices = [];
    let selectedVoiceURI = "";

    // statuses: map word -> 'none' | 'spelled' | 'mastered'
    let statuses = {};
    const STORAGE_KEY = "spelling-cards-statuses-v1";

    function loadStatusesFromStorage() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          if (typeof parsed === "object" && parsed !== null) {
            statuses = parsed;
          }
        }
      } catch (e) {
        console.warn("Could not load statuses:", e);
      }
    }

    function saveStatusesToStorage() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(statuses));
      } catch (e) {
        console.warn("Could not save statuses:", e);
      }
    }

    function normalizeWord(w) {
      return w.trim().replace(/\s+/g, " ");
    }

    function loadWordsFromText(text) {
      const list = text.split("\n")
        .map(normalizeWord)
        .filter(Boolean);

      const seen = new Set();
      words = list.filter(w => (seen.has(w) ? false : (seen.add(w), true)));

      // Ensure statuses has entries for words we've seen before (but don't wipe existing)
      // (we keep statuses by word key; if words change, those keys remain in localStorage)
      idx = 0;
      revealed = true;
      render();
    }

    function wiktionaryUrl(word) {
      return "https://en.wiktionary.org/wiki/" + encodeURIComponent(word);
    }

    function googleDefineUrl(word) {
      return "https://www.google.com/search?q=" + encodeURIComponent("define " + word);
    }

    function updateBackupLinks(word) {
      const wUrl = wiktionaryUrl(word);
      const gUrl = googleDefineUrl(word);
      els.backupLinks.innerHTML = ` <a href="${wUrl}" target="_blank" rel="noreferrer">Wiktionary</a> ‚Ä¢
        <a href="${gUrl}" target="_blank" rel="noreferrer">Google define</a>`;
    }

    function updateDashboard() {
      const total = words.length;
      let spelledCount = 0;
      let masteredCount = 0;

      words.forEach(w => {
        const s = statuses[w];
        if (s === "spelled") spelledCount++;
        if (s === "mastered") masteredCount++;
      });

      const notMasteredCount = total - masteredCount;

      els.countSpelled.textContent = spelledCount;
      els.countMastered.textContent = masteredCount;
      els.countNotMastered.textContent = notMasteredCount;

      const percent = total === 0 ? 0 : Math.round((masteredCount / total) * 100);
      els.progressFill.style.width = percent + "%";
      els.percentMastered.textContent = percent + "%";
    }

    function setStatusForWord(word, status) {
      if (!word) return;
      if (status === "none") {
        delete statuses[word];
      } else {
        statuses[word] = status;
      }
      saveStatusesToStorage();
      render(); // update UI
    }

    function createStatusButtons(current) {
      // Clear
      els.statusArea.innerHTML = "";

      if (!current) return;

      const currentStatus = statuses[current] || "none";

      // Spelled button
      const spelledBtn = document.createElement("button");
      spelledBtn.className = "status-btn";
      spelledBtn.textContent = "Spelled";
      if (currentStatus === "spelled") spelledBtn.classList.add("active");
      spelledBtn.addEventListener("click", () => {
        const newStatus = (statuses[current] === "spelled") ? "none" : "spelled";
        setStatusForWord(current, newStatus);
      });

      // Mastered button
      const masteredBtn = document.createElement("button");
      masteredBtn.className = "status-btn mastered";
      masteredBtn.textContent = "Mastered";
      if (currentStatus === "mastered") {
        masteredBtn.classList.add("active");
      }
      masteredBtn.addEventListener("click", () => {
        const newStatus = (statuses[current] === "mastered") ? "none" : "mastered";
        setStatusForWord(current, newStatus);
      });

      // Clear (optional) - quick reset for this word
      const clearBtn = document.createElement("button");
      clearBtn.className = "status-btn clear";
      clearBtn.textContent = "Clear";
      clearBtn.addEventListener("click", () => {
        setStatusForWord(current, "none");
      });

      // Add a small label showing current status
      const statusLabel = document.createElement("div");
      statusLabel.className = "small";
      statusLabel.style.marginLeft = "8px";
      statusLabel.textContent = currentStatus === "none" ? "Not marked" : currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);

      els.statusArea.appendChild(spelledBtn);
      els.statusArea.appendChild(masteredBtn);
      els.statusArea.appendChild(clearBtn);
      els.statusArea.appendChild(statusLabel);
    }

    function render() {
      if (words.length === 0) {
        els.word.textContent = "‚Äî";
        els.counter.textContent = "0 / 0";
        els.prevBtn.disabled = true;
        els.nextBtn.disabled = true;
        els.revealBtn.disabled = true;
        els.statusArea.innerHTML = "";
        updateDashboard();
        return;
      }

      const mode = els.mode.value;
      const current = words[idx];

      els.counter.textContent = `${idx + 1} / ${words.length}`;
      els.prevBtn.disabled = idx === 0;
      els.nextBtn.disabled = idx === words.length - 1;
      els.revealBtn.disabled = (mode === "show");

      if (mode === "show") {
        els.word.textContent = current;
      } else {
        els.word.textContent = revealed ? current : "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢";
      }

      updateBackupLinks(current);
      createStatusButtons(current);
      updateDashboard();
    }

    function next() {
      if (idx < words.length - 1) {
        idx++;
        revealed = (els.mode.value === "show");
        render();
      }
    }

    function prev() {
      if (idx > 0) {
        idx--;
        revealed = (els.mode.value === "show");
        render();
      }
    }

    function shuffle() {
      for (let i = words.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [words[i], words[j]] = [words[j], words[i]];
      }
      idx = 0;
      revealed = (els.mode.value === "show");
      render();
    }

    // ---- Text-to-Speech ----
    function ttsAvailable() {
      return typeof window.speechSynthesis !== "undefined" && typeof SpeechSynthesisUtterance !== "undefined";
    }

    function stopSpeaking() {
      if (ttsAvailable()) window.speechSynthesis.cancel();
    }

    function speakWord(word) {
      if (!ttsAvailable()) {
        alert("Text-to-speech isn‚Äôt available in this browser. Use the pronunciation links below.");
        return;
      }

      stopSpeaking();

      const rate = parseFloat(els.rate.value || "1");
      const repeat = parseInt(els.repeat.value || "1", 10);

      // iOS sometimes needs a short delay after cancel()
      setTimeout(() => {
        for (let i = 0; i < repeat; i++) {
          const u = new SpeechSynthesisUtterance(word);
          u.rate = rate;

          const voice = voices.find(v => v.voiceURI === selectedVoiceURI) || null;
          if (voice) u.voice = voice;

          window.speechSynthesis.speak(u);
        }
      }, 50);
    }

    function populateVoices() {
      if (!ttsAvailable()) {
        els.ttsStatus.textContent = "TTS: not supported";
        els.ttsStatus.style.background = "#fee2e2";
        return;
      }

      voices = window.speechSynthesis.getVoices() || [];
      els.voiceSelect.innerHTML = "";

      // Prefer English voices first
      const sorted = [...voices].sort((a,b) => {
        const aEn = (a.lang || "").toLowerCase().startsWith("en");
        const bEn = (b.lang || "").toLowerCase().startsWith("en");
        if (aEn !== bEn) return aEn ? -1 : 1;
        return (a.name || "").localeCompare(b.name || "");
      });

      sorted.forEach(v => {
        const opt = document.createElement("option");
        opt.value = v.voiceURI;
        opt.textContent = `${v.name} (${v.lang})`;
        els.voiceSelect.appendChild(opt);
      });

      // Choose a default voice
      const defaultVoice =
        sorted.find(v => /en-us/i.test(v.lang)) ||
        sorted.find(v => (v.lang || "").toLowerCase().startsWith("en")) ||
        sorted[0];

      if (defaultVoice) {
        selectedVoiceURI = defaultVoice.voiceURI;
        els.voiceSelect.value = selectedVoiceURI;
        els.ttsStatus.textContent = "TTS: ready";
        els.ttsStatus.style.background = "#dcfce7";
      } else {
        els.ttsStatus.textContent = "TTS: no voices";
        els.ttsStatus.style.background = "#fee2e2";
      }
    }

    // Some browsers load voices asynchronously
    if (ttsAvailable()) {
      window.speechSynthesis.onvoiceschanged = populateVoices;
      // Try now as well
      populateVoices();
    } else {
      populateVoices();
    }

    // Wire up events
    els.nextBtn.addEventListener("click", next);
    els.prevBtn.addEventListener("click", prev);
    els.shuffleBtn.addEventListener("click", shuffle);

    els.revealBtn.addEventListener("click", () => {
      revealed = true;
      render();
    });

    els.mode.addEventListener("change", () => {
      revealed = (els.mode.value === "show");
      render();
    });

    els.voiceSelect.addEventListener("change", () => {
      selectedVoiceURI = els.voiceSelect.value;
    });

    els.speakBtn.addEventListener("click", () => {
      if (words.length === 0) return;
      const current = words[idx];
      speakWord(current);
    });

    els.stopBtn.addEventListener("click", stopSpeaking);

    els.loadBtn.addEventListener("click", () => {
      loadWordsFromText(els.wordList.value);
    });

    els.resetBtn.addEventListener("click", () => {
      els.wordList.value = DEFAULT_WORDS;
      loadWordsFromText(DEFAULT_WORDS);
    });

    // Keyboard shortcuts
    window.addEventListener("keydown", (e) => {
      if (e.key === "ArrowRight") next();
      if (e.key === "ArrowLeft") prev();
      if (e.key.toLowerCase() === "r" && els.mode.value === "hide") { revealed = true; render(); }
      if (e.key.toLowerCase() === "s") shuffle();
      if (e.key === " " || e.key.toLowerCase() === "p") { // space / p to pronounce
        e.preventDefault();
        if (words.length) speakWord(words[idx]);
      }
      if (e.key === "Escape") stopSpeaking();
    });

    // Init
    loadStatusesFromStorage();
    els.wordList.value = DEFAULT_WORDS;
    loadWordsFromText(DEFAULT_WORDS);
  </script>
</body>
</html>
